---
title: "What wefwefwef"
date: "2022-11-03"
---

A lot of things happen after you type a URL in the address bar of your browser and press Enter, and before the browser can show the page to you. First of all, the browser needs to *resolve* the hostname part of the URL to an IP address of the web server. This is because other computers on the Internet are accessible by their IP addresses, not their names.


{% extra() %}
IP addresses look like this `172.217.175.78` (IPv4) or like this `2001:4860:4860::8888` (IPv6). The browser tries to learn both and then use an algorithm with a weird name ["Happy Eyeballs"](https://en.wikipedia.org/wiki/Happy_Eyeballs) to decide which to use.
{% end %}

 The mapping from the (sub)domain to the address could be right in the browser's cache, but sometimes the browser needs to get the answer elsewhere. For example, in your operating system's cache or even from a remote DNS ([Domain Name System](https://en.wikipedia.org/wiki/Domain_Name_System)) server, which is also called a *nameserver*. DNS is also the name of the protocol that is used to query these specially designed servers and find out which (sub)domains map to which IP addresses. A protocol is a language that two computers on the network can understand and DNS is just one of the many. Your OS likely has an API that applications like a browser can use to send DNS queries to the Internet. For example, the [`getaddrinfo`](https://man7.org/linux/man-pages/man3/getaddrinfo.3.html) function from [C library](https://en.wikipedia.org/wiki/C_standard_library), which has many other useful functions used by both applications and the operating system. If your OS does not find the answer in its DNS cache either, it sends a DNS query to the configured nameserver. The query asks the server for the A (or AAAA) record, which is an entry in the database that maps the (sub)domain to an IPv4 (or IPv6) address. 
 
 How does your computer know the address of the DNS server? You might have configured it manually (like [`8.8.8.8`](https://developers.google.com/speed/public-dns)) or it might have been configured automatically by [DHCP](https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol) (Dynamic Host Configuration Protocol), which is also used by your computer to get its own IP address from your LAN (or your ISP's) router. Once the nameserver's IP address is known, the operating system opens a [UDP](https://en.wikipedia.org/wiki/User_Datagram_Protocol) *socket*, a special entity (an actual file in Linux) that is used to communicate on the network. The socket is assigned a *port* number from 1024 to 65535 that identifies the socket locally. The remote server has a similar open UDP socket but with a port number 53. UDP is a transport-level protocol that is used to "carry" higher-level messages like DNS queries over the Internet. I know what you are thinking: "That's a lot of protocols!". And you are right, because there are more, so buckle up for the ride. Quite a few things happen before the UDP messages called *datagrams* reach the nameserver and before the response comes back to your computer. Because getting the actual page from the web server is a similar process, I return to it in detail below. For now, imagine that the nameserver successfully received your query. The nameserver might not have an answer for you, in which case it forwards the query to other nameservers and those nameservers can repeat the process until the *authoritative* nameserver for that domain either gives you the answer or just says "I don't know" and ruins your day. Suppose the address exists and `getaddrinfo` function used by your browser returns with an IP address, which the browser can finally use to send the request for the page.

To get a web page, browsers use [HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP). HTTP is an application-level protocol that makes it easier to express requests like "I want a resource at path `/cats.html`"  or "Save this user's data at path `/users`". It would be almost impossible to make this a part of a transport-level protocol. The browser assumes that there is an HTTP server listening for requests at the IP address it just learned. That server usually has an open [TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol) socket with port number 80 or 443. TCP, like UDP, is the transport-level protocol which usually "carries" HTTP messages, though it can be used to "carry" DNS as well. The browser needs to only create a valid HTTP request that looks like this, literally:

```
GET / HTTP/1.1
Host: github.com
``` 

It contains a verb (`GET`) that reflects what the browser wants to do, the path of the resource (`/`), the protocol version used (`HTTP/1.1`) and the `Host` header that is a (sub)domain name.

Then the browser asks the operating system to open a TCP socket and send the HTTP request to the IP address of the server and port 80 (which is usually expressed together as `172.217.175.78:80`). The browser does not need to know how to create TCP messages (called *segments*) at all - that is handled by the implementation of the TCP/IP stack that is part of any major operating system. The OS "wraps" the first TCP segment in an IP *packet* and sets the source and destination addresses. This is a good time to point out that IP itself is a protocol. After all IP is an abbreviation of *Internet Protocol*! This is the level at which routing across networks happens and allows your packet to reach the destination. Note that TCP segments only have source and destination port numbers in them, but not IP addresses. Finally, the OS "wraps" the IP packet in an [Ethernet](https://en.wikipedia.org/wiki/Ethernet) *frame*. Ethernet is a lowest, link layer protocol that uses [MAC addresses](https://en.wikipedia.org/wiki/MAC_address) to send messages between [NICs](https://en.wikipedia.org/wiki/Network_interface_controller) (Network Interface Controller) of two or more devices. The OS uses the driver software of the network interface (which is called something like `eth0` on your computer) to send the Ethernet frame as physical signals.

{% extra() %}
You are probably noticing some pattern. The system keeps wrapping, or *encapsulating* things into other things. This is the known as the TCP/IP model of networking. The TCP/IP model organizes protocols in layers such that each layer is only concerned with its own "job": data link layer only needs to deliver (and verify integrity of) Ethernet messages by MAC address within a LAN. Network layer is concerned with routing IP packets (which encapsulate link layer messages) across networks separated by routers. Transport layer can provide retransmission of lost network layer packets and their order. Application layer can be used for whatever you want.

![tcpip](tcpip.png)

{% end %}
