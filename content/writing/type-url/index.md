---
title: "What wefwefwef"
date: "2022-11-03"
---

A lot of things happen after you type a URL in the address bar of your browser and press Enter, and before the browser can show the page to you. First of all, the browser needs to *resolve* the hostname part of the URL to an IP address of the web server. This is because other computers on the Internet are accessible by their IP addresses, not their names.


{% extra() %}
IP addresses look like this `172.217.175.78` (IPv4) or like this `2001:4860:4860::8888` (IPv6). The browser tries to learn both and then use an algorithm with a weird name ["Happy Eyeballs"](https://en.wikipedia.org/wiki/Happy_Eyeballs) to decide which to use for better performance. In fact you can skip the domain name resolution altogether and just type the IP address directly if you know it.
{% end %}

 The mapping from the (sub)domain to the address could be right in the browser's cache, but sometimes the browser needs to get the answer elsewhere. For example, in your operating system's cache or even from a remote DNS ([Domain Name System](https://en.wikipedia.org/wiki/Domain_Name_System)) server, which is also called a *nameserver*. DNS is also the name of the protocol that is used to query these specially designed servers and find out which (sub)domains map to which IP addresses. A protocol is a language that two computers on the network can understand and DNS is just one of the many. Your OS likely has an API that applications like a browser can use to send DNS queries to the Internet. For example, the [`getaddrinfo`](https://man7.org/linux/man-pages/man3/getaddrinfo.3.html) function from [C library](https://en.wikipedia.org/wiki/C_standard_library), which has many other useful functions used by both applications and the operating system. If your OS does not find the answer in its DNS cache either, it sends a DNS query to the configured nameserver. The query asks the server for the A (or AAAA) record, which is an entry in the database that maps the (sub)domain to an IPv4 (or IPv6) address.

{% extra() %}
Yet another way to resolve the domain name is [mDNS](https://en.wikipedia.org/wiki/Multicast_DNS) (Multicast DNS). In some cases, like when the top-level domain is `.local`, the computer would send a special message to every device on the LAN that asks "whoever has this domain name - tell me your IP address". If some device indeed has the domain name in question it sends its IP address in the response to your computer. Sending to every device on LAN is possible by using a *multicast* IP address.
{% end %}
 
 How does your computer know the address of the DNS server? You might have configured it manually (like [`8.8.8.8`](https://developers.google.com/speed/public-dns)) or it might have been configured automatically by [DHCP](https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol) (Dynamic Host Configuration Protocol), which is also used by your computer to get its own IP address from your LAN (or your ISP's) router. Once the nameserver's IP address is known, the operating system opens a [UDP](https://en.wikipedia.org/wiki/User_Datagram_Protocol) *socket*, a special entity (an actual file in Linux) that is used to communicate on the network. The socket is assigned a *port* number from 1024 to 65535 that identifies the socket locally. The remote server has a similar open UDP socket but with a port number 53. UDP is a transport-level protocol that is used to "carry" higher-level messages like DNS queries over the Internet. I know what you are thinking: "That's a lot of protocols!". And you are right, because there are more, so buckle up for the ride. Quite a few things happen before the UDP messages called *datagrams* reach the nameserver and before the response comes back to your computer. Because getting the actual page from the web server is a similar process, I return to it in detail below. For now, imagine that the nameserver successfully received your query. The nameserver might not have an answer for you, in which case it forwards the query to other nameservers and those nameservers can repeat the process until the *authoritative* nameserver for that domain either gives you the answer or just says "I don't know" and ruins your day. Suppose the address exists and `getaddrinfo` function used by your browser returns with an IP address, which the browser can finally use to send the request for the page.

To get a web page, browsers use [HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP). HTTP is an application-level protocol that makes it easier to express requests like "I want a resource at path `/cats.html`"  or "Save this user's data at path `/users`". It would be almost impossible to make this a part of a transport-level protocol. The browser assumes that there is an HTTP server listening for requests at the IP address it just learned. That server usually has an open [TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol) socket with port number 80 or 443. TCP, like UDP, is the transport-level protocol which usually "carries" HTTP messages, though it can be used to "carry" DNS as well. The browser needs to only create a valid HTTP request that looks like this, literally:

```
GET / HTTP/1.1
Host: github.com
``` 

It contains a verb (`GET`) that reflects what the browser wants to do, the path of the resource (`/`), the protocol version used (`HTTP/1.1`) and the `Host` header that is a (sub)domain name. There is a bunch of other headers which can reflect the user's preference for a certain language of the page (`Accept-Language` header), information that identifies the user (`Cookie` or the `Authorization` header) etc.

Then the browser asks the operating system to open a TCP socket and send the HTTP request to the IP address of the server and port 80 (which is usually expressed together as `172.217.175.78:80`). The browser does not need to know how to create TCP messages (called *segments*) at all - that is handled by the implementation of the TCP/IP stack that is part of any major operating system. The OS "wraps" the first TCP segment in an IP *packet* and sets the source and destination addresses. This is a good time to point out that IP itself is a protocol. After all IP is an abbreviation of *Internet Protocol*! This is the level at which routing across networks happens and allows your packet to reach the destination. Note that TCP segments only have source and destination port numbers in them, but not IP addresses. Finally, the OS "wraps" the IP packet in an [Ethernet](https://en.wikipedia.org/wiki/Ethernet) *frame*. Ethernet is a lowest, link layer protocol that uses [MAC addresses](https://en.wikipedia.org/wiki/MAC_address) to send messages between [NICs](https://en.wikipedia.org/wiki/Network_interface_controller) (Network Interface Controller) of two or more devices. The OS uses the driver software of the network interface (which is called something like `eth0` on your computer) to send the Ethernet frame as physical signals.

{% extra() %}
You are probably noticing some pattern. The system keeps wrapping, or *encapsulating* things into other things. This is the known as the TCP/IP model of networking. The TCP/IP model organizes protocols in layers such that each layer is only concerned with its own "job": data link layer only needs to deliver (and verify integrity of) Ethernet messages by MAC address within a LAN. Network layer is concerned with routing IP packets (which encapsulate link layer messages) across networks separated by routers. Transport layer can provide retransmission of lost network layer packets and their order. Application layer can be used for whatever you want.

![tcpip](tcpip.png)

A message at every layer begins with a header that is just a bunch of bytes in certain order. These bytes have special meaning that is defined in a RFC. For example, IP packet headers include information like protocol version and total length of contents before the source address field. TCP segment headers include information like segment number, source/destination port number, window size etc. In the screenshot below, I used Wireshark to analyze my own traffic. I ran a `dig` command to resolve my blog's domain name `kirillvasiltsov.com` to an IP address. You can see encapsulation in action: Ethernet header is marked with yellow, IP header with blue, UDP header with orange and the rest is DNS header + message.

![encapsulation](encapsulation.png)
{% end %}

But can the computer be sure that the HTTP message it sends out if its network interface reaches the destination? Well, most home computers only have one network interface so there is only one way out. While your computer is not a router, it has a routing table that it uses to make routing decisions too. The decision making is the same for all devices - if the destination IP address is not in your subnet (which is usually your whole home network) then send the message to the *default gateway*. The default gateway is your router and both its IP address and MAC address is what your computer learns via DHCP at some point during the boot.


{% extra() %}
If you have several computers on your LAN connected with a switch, then if you try to access some web page hosted on one of those computers, the HTTP request will not go through the router but go directly to the neighbor. How can the message find its way? Your computer, like a router, has [ARP](https://en.wikipedia.org/wiki/Address_Resolution_Protocol) (Address Resolution Protocol) cache. ARP is yet another protocol that is used to learn MAC addresses of devices that have a particular IP addresses. So when you send a HTTP request to a local web server with an IP in your subnet, your OS checks the ARP table to set the correct MAC address, which is used by the switch to forward the message out of the correct network interface.
{% end %}

Suppose that the web page you want to see is hosted by a server in a remote network. Your default gateway has only one way out to the WAN (Wide Area Network) too, so it just forwards the packet to your ISP's router on the other side, using its *default route* `0.0.0.0/0` with an associated network interface. This route is used for all destinations that your router does not know (not directly connected or learned from other routers in the network).
